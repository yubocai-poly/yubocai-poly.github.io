<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | Yubo CAI 蔡宇博</title>
    <link>https://example.com/project/</link>
      <atom:link href="https://example.com/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 15 Jan 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://example.com/media/icon_hu7b727f29fe192dd60caa35df48776129_3965_512x512_fill_lanczos_center_3.png</url>
      <title>Projects</title>
      <link>https://example.com/project/</link>
    </image>
    
    <item>
      <title>PaperFriend</title>
      <link>https://example.com/project/cse201/</link>
      <pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/cse201/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Algorithms for Numerical Analysis of Catalan Numbers</title>
      <link>https://example.com/project/205/</link>
      <pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/205/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Nim Games with Coq</title>
      <link>https://example.com/project/203/</link>
      <pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/203/</guid>
      <description>&lt;h1 id=&#34;nim-game&#34;&gt;Nim Game&lt;/h1&gt;
&lt;p&gt;This is the final project for CSE203 - Logic and Proof at Ecole Polytechnique. The project was finished by &lt;a href=&#34;https://github.com/frank2002&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Junyuan Wang&lt;/a&gt; and me, under the supervision from &lt;a href=&#34;http://www.strub.nu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prof. Pierre-Yves Strub&lt;/a&gt; and &lt;a href=&#34;http://www.lix.polytechnique.fr/Labo/Benjamin.Werner/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prof. Benjamin Werner&lt;/a&gt;. The project was finally defended under the supervision of &lt;a href=&#34;http://www.strub.nu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prof. Pierre-Yves Strub&lt;/a&gt;. You can find the code and slide from following link.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Code] - &lt;a href=&#34;https://github.com/yubocai-poly/Nim-Game/blob/main/Project/nim.v&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Slides] - &lt;a href=&#34;https://github.com/yubocai-poly/Nim-Game/blob/main/Project/CSE203_Final_Project.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction-to-the-project&#34;&gt;Introduction to the Project&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Nim is a mathematical game of strategy in which two players take turns removing objects from distinct heaps or piles. For more information, you can access the &lt;a href=&#34;https://en.wikipedia.org/wiki/Nim#Game_play_and_illustration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[wiki page]&lt;/a&gt; of nim game. The purpose of this project is to try to accomplish a formal proof of the winning strategy of the nim game through the &lt;strong&gt;Coq&lt;/strong&gt; language. For more information about Nim Game&amp;rsquo;s winning strategy you can visit the following &lt;a href=&#34;https://en.wikipedia.org/wiki/Nim#Mathematical_theory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[link]&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;winning-strategy-of-nim-game&#34;&gt;Winning Strategy of Nim Game&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;In a normal Nim game, the player making the first move has a winning strategyu if and only if the nim-sum of the sizes of the heaps is not zero. Otherwise, the second player has a winning strategy. The winning strategy is to make the nim sum becomes 0 after each move.&lt;/p&gt;
&lt;p&gt;Notice that the nim-sum $(\oplus)$ obeys the usual associative and commutative laws of addition (+) and also satisfies an additional property, $x \oplus x = 0$.&lt;/p&gt;
&lt;p&gt;Let $x_1, \ldots, x_n$ be the sizes of the heaps before a move, and $y_1, \ldots, y_n$ the corresponding sizes after a move. Let $s=x_1 \oplus \ldots \oplus x_n$ and $t=y_1 \oplus \ldots \oplus y_n$. If the move was in heap $k$, we have $x_i=y_i$ for all $i \neq k$, and $x_k&amp;gt;y_k$. By the properties of $\oplus$ mentioned above, we have&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    t = 0 ⊕ t
      = s ⊕ s ⊕ t
      = s ⊕ (x1 ⊕ ... ⊕ xn) ⊕ (y1 ⊕ ... ⊕ yn)
      = s ⊕ (x1 ⊕ y1) ⊕ ... ⊕ (xn ⊕ yn)
      = s ⊕ 0 ⊕ ... ⊕ 0 ⊕ (xk ⊕ yk) ⊕ 0 ⊕ ... ⊕ 0
      = s ⊕ xk ⊕ yk
 
(*) t = s ⊕ xk ⊕ yk.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, the theorem follows by induction on the length of the game from these two lemmas. Here we denote $s$ is the state before move and $t$ (or $s&amp;rsquo;$) is the state after move. Also, the number here means nim sum.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lemma 1.&lt;/strong&gt; If $s=0$, then $t \neq 0$ no matter what move is going to have next. (&lt;strong&gt;Lemma z2nz&lt;/strong&gt; in Coq)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lemma 2.&lt;/strong&gt; If $s\neq 0$, there exist one move that make $t=0$. (&lt;strong&gt;Lemma nz2z&lt;/strong&gt; in Coq)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;structure-of-the-code-for-project&#34;&gt;Structure of the code for project&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Part 1.&lt;/strong&gt; Numberical Lemma on list, binary numbers and bxor operations&amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part 2.&lt;/strong&gt; Definition for state, rows, bijective relation&amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part 3.&lt;/strong&gt; Operations and Lemma on weights&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part 4.&lt;/strong&gt; Proof for &lt;strong&gt;turn_weight&lt;/strong&gt;, &lt;strong&gt;z2nz&lt;/strong&gt;, and &lt;strong&gt;nz2z&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;code-for-operations-and-lemma-on-weights&#34;&gt;Code for Operations and Lemma on weights&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;This part of code are operations and Lemma on weights, we prove by induction and operations in bxor.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-coq&#34; data-lang=&#34;coq&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_empty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_r0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bits0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;nat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n2b&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_rS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;nat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;nat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n2b&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight_rD&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;nat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bxor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;weight_r&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;proof-for-z2nz&#34;&gt;Proof for z2nz&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;We apply contradiction to prove &lt;strong&gt;z2nz&lt;/strong&gt; that if $s = 0$, then $t \neq 0$ no matter what move is made.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-coq&#34; data-lang=&#34;coq&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z2nz&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;I_p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weight&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We need to prove other two Lemma where $x \oplus x=0$ and $\forall n \in \mathbb{N}, n &amp;lt; n, \rightarrow false$ in order to create contradiction.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-coq&#34; data-lang=&#34;coq&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b02bnbb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;I_p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n2b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n2b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;Lemma&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ltf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;nat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We have &lt;strong&gt;n2b_inj&lt;/strong&gt; that we can duduce that &lt;strong&gt;s2 i = s1 i&lt;/strong&gt; which is contradiction with the assupmtion that &lt;strong&gt;s2 i &amp;lt; s1 i&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;proof-for-nz2z&#34;&gt;Proof for nz2z&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;We prove if $s \neq 0$, it is possible to make a move so that $s^{\prime}=0$ $\mathbf{n z 2 z}$ in following steps. We denote $x_1, \cdots, x_n$ is the number for each row before the move, $y_1, \cdots, y_n$ is the number for each row after the move&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$d$ be the position of leftmost nonzero bit in the binary representation of $s$ exists.&lt;/li&gt;
&lt;li&gt;Prove $\exists k$ such that $x_{k}[d] \neq 0$. We prove this by contradiction.&lt;/li&gt;
&lt;li&gt;We set $y_{k} = s \oplus x_k$ and assume $y_{k} &amp;lt; x_{k}$, then we prove $\forall i, d &amp;lt; i \rightarrow x_{k}=y_{k}$.&lt;/li&gt;
&lt;li&gt;Finish the prove with weight $s&amp;rsquo; = 0%:B$ or R k s s&#39;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rigorous Proof of Frobenius Reduction</title>
      <link>https://example.com/project/201/</link>
      <pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/201/</guid>
      <description>&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This work is originally from the Homework of the abstract algebra course at Ecole Polytechnique for &lt;strong&gt;MAA201-Reduction of Endomorphisms&lt;/strong&gt;. And I spend this work on this project.&lt;/p&gt;
&lt;p&gt;In the first part you can see some rigorous proof of &lt;strong&gt;Gauss’s Lemma&lt;/strong&gt; and &lt;strong&gt;Eisenstein’s Criterion&lt;/strong&gt;, and some application in the analysis of the reducibility of the monic polynomials.&lt;/p&gt;
&lt;p&gt;And in the second part, we will see the proof of &lt;strong&gt;Frobenius Reduction&lt;/strong&gt; which in French is &lt;strong&gt;Decomposition de Frobenius&lt;/strong&gt;. Since there is no really detailed proof of this in English so here you can find the Lemma and proof relatively in order to prove this theorem.&lt;/p&gt;
&lt;h2 id=&#34;copyright&#34;&gt;Copyright&lt;/h2&gt;
&lt;p&gt;Copyright by &lt;code&gt;Yubo Cai&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Pricing an option with binomial models</title>
      <link>https://example.com/project/107/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/107/</guid>
      <description>&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;The objective is to study how can we apply binomial models in the pricing of some financial products like saving, stocks and options.&lt;/p&gt;
&lt;p&gt;In the first part of the project we discuss more general situations about the non-risky products like savings and risky products like stocks which evolve randomly with respect to time. Then in the second part of the project, we gonna discuss options in different time periods and give the general case with more details.&lt;/p&gt;
&lt;p&gt;At the end of the project, we give another expression and our conclusion and remarks.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;general-assumptions-and-underlying-models&#34;&gt;General assumptions and underlying models&lt;/h2&gt;
&lt;p&gt;To begin with, we assume that all the financial assets in our problem can be infinitely divided. Also, we regard that they can be sold even if the agent does not have them. That is, we can own actually negative units of a certain financial asset. In our project, we will always consider a simple financial market that only contains the following three types of financial assets:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Non-risky products (savings in particular) with an interest $r$.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Risky products (stocks in particular) which evolves randomly with respect to time.&lt;/strong&gt;
We can model the price of stocks (denoted by S) in the following way. Assume at each step, the price will either be multiplied by a scalar u ($ u \geq 1$), or be multiplied by another scalar d ($d \leq 1$). To note that  this process is assumed to be perfectly fair. That is to say, the price will either go through a fixed rising process or a fixed decreasing process and the probability of which is equal. We denote the rising process as  H  and the decreasing process as  T  and use them to manifest the index of the price. For instance, if the price first went up, then went down for successively two times, we can denote the index as (H, T, T). The figure below gives a more complete example. We will denote $\Omega$ as the set of all the possible indices at the last stage involved in the process. We have:

   $$
   \Omega=\left\{\begin{array}{l}
   \{H H, H T, T H, T T\}, \text { after two steps } \\
   \{H H H, H H T, H T H, H T T, T H H, T H T, T T H, T T T\}, \text { after three steps }
   \end{array}\right.
   $$
   
If $\omega$ is an element of $\Omega$, we will denote $\omega_{k}$ as the $k^{th}$ component of $\omega$. The price of the stock with all the possible outcomes up to two steps with $S_0=4$, $u=2$ and $d=\frac{1}{2}$ is given below:
&lt;img src=&#34;pic1.png&#34;&gt;
Here $S_n(\omega)=p \times S_{n-1}(\omega-\omega_n)$, where $p=2$ if ${\omega_n}=H$ and $p=\frac{1}{2}$ if ${\omega_n}=T$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Another risky product: option.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We will consider a European option, which is, by definition, a version of an options contract that limits execution to its expiration date. In other words, if the underlying security has moved in price, an investor would not be able to exercise the option early and take delivery of or sell the shares. If the strike price of an option is denoted by K and the expiration is n years, our final payoff of such a call option denoted by $V_{n}$ will satisfy that $V_{n}(\omega) = max{0, S_{n}(\omega)-K}$. Indeed, under an index $\omega$ of the stock price, if the price is higher than the strike price, we will sell the stocks and get some money, if the price is lower than the strike price, the best choice is obviously to do nothing as one will lose money otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;copyright&#34;&gt;Copyright&lt;/h2&gt;
&lt;p&gt;Copyright by &lt;code&gt;Yubo Cai&lt;/code&gt;, &lt;code&gt;Tianli Xu&lt;/code&gt;, &lt;code&gt;Zhuoya Zhang&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Collected Game Website</title>
      <link>https://example.com/project/104/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/104/</guid>
      <description>&lt;p&gt;CSE104 is the courses held by Professor Rohmer Damien at Ecole Polytechnique. And this is the final project related to this course. In this project, we tried to create an integrated website by using HTML, CSS and Javascript, with a recreation of the classic trivia game with those tools.&lt;/p&gt;
&lt;h2 id=&#34;website&#34;&gt;Website&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://webgamecse104.netlify.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;professors&#34;&gt;Professors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imagecomputing.net/damien.rohmer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rohmer Damien&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contributors&#34;&gt;Contributors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/frank2002&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Junyuan Wang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yubocai-poly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yubo Cai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tools-of-this-course&#34;&gt;Tools of this course&lt;/h2&gt;
&lt;p&gt;VScode, HTML, CSS, Javascript&lt;/p&gt;
&lt;h2 id=&#34;copyright&#34;&gt;Copyright&lt;/h2&gt;
&lt;p&gt;Copyright by Yubo Cai and Junyuan Wang&lt;/p&gt;
&lt;iframe id=&#34;myframe&#34;
      src=&#34;https://docdro.id/Z02e8Wp&#34;
      width=&#34;100%&#34; height=&#34;800&#34; frameborder=&#34;1&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Lossy Image Compression</title>
      <link>https://example.com/project/example/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/example/</guid>
      <description>&lt;h1 id=&#34;cse102-advanced-programming-final-project&#34;&gt;CSE102-Advanced-Programming-Final-Project&lt;/h1&gt;
&lt;h2 id=&#34;project-instruction&#34;&gt;Project Instruction&lt;/h2&gt;
&lt;p&gt;The goal of this project is to develop a lossy image compression format close to JPEG. Lossy compression algorithms allow to greatly reduce the size of image files at the price of loosing some data from the original image. In general, a lossy image compression works by pruning the information the human eye is not sensible to. This is the case, for instance, in the JPEG file format.&lt;/p&gt;
&lt;p&gt;The JPEG compression algorithm can be decomposed into several steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In theory, JPEG-based compression schemes are independent of the image color-space (e.g. Red-Green-Blue). However the best rates of compression are obtained in a color space that separates the light-intensity (luminance) from the color information (chrominance). Indeed, the human eye is quite sensitive to luminance but little to chrominance and we can then afford to lose more chrominance information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hence, the algorithm starts by converting the original image from its initial RGB (Red-Green-Blue) colorimetric model towards the YCbCr model of type luminance/chrominance. In this model, Y is the information of luminance, and Cb and Cr give chrominance values, respectively the blue minus Y and the red minus Y.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This low sensitivity of the human eye to chrominance is exploited by performing a subsampling of the color signals. The principle of the operation is to reduce the size of several blocks of chrominance in a single value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The image is then split into blocks of 8×8 subpixels.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A 2D DCT (Discrete Cosine Transform) is then applied to each block. The DCT is a variant of the Fourier transform. It decomposes a block, considered as a function in two variables, into a sum of cosine functions. Each block is thus described in a map of frequencies and amplitudes rather than in pixels and color information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then, a quantization step takes place. The quantization consists in dividing the DCT matrix by another one, called quantization matrix. The goal here is to attenuate the high frequencies, i.e. those to which the human eye is very insensitive. These frequencies have low amplitudes, and they are further attenuated by quantization (some coefficients are even often reduced to 0).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, each block is coded using a variation of the Run-length encoding associated with an arithmetic coding – both are lossless data compression algorithm.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;project-schedule&#34;&gt;Project Schedule&lt;/h2&gt;
&lt;p&gt;The goal of this project is to write a JPEG-like image encoder/decoder. This is a 3-week project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;during the first week, we will focus on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loading / saving image files,&lt;/li&gt;
&lt;li&gt;converting images between the RGB &amp;amp; the YCbCr color space, and&lt;/li&gt;
&lt;li&gt;performing channels subsampling.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;during the second week, we will focus on the DCT transform, and&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;during the third week, we will consider the RLE &amp;amp; arithmetic coding.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;professors&#34;&gt;Professors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.strub.nu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pierre-Yves Strub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contributors&#34;&gt;Contributors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yubocai-poly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yubo Cai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tools-of-this-course&#34;&gt;Tools of this course&lt;/h2&gt;
&lt;p&gt;VScode, Python, Numpy, matplotlib, mathematical analysis&lt;/p&gt;
&lt;p&gt;In this project, you need some basic knowledge about Linear Algebra like &lt;strong&gt;Matrix multplication&lt;/strong&gt; and &lt;strong&gt;Fouier Transformation&lt;/strong&gt;. However &lt;strong&gt;Numpy&lt;/strong&gt; is forbiddened in this project.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Research Porject about Acceleration of the solution of Fractional Diffusion Equations in time</title>
      <link>https://example.com/project/inria/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/project/inria/</guid>
      <description>&lt;p&gt;This research project is under the supervision of Professor Olivier about his new method and algorithms in the numerical solution of time-fractional diffusion equation. Our overall thinking is based on these two papers: &lt;a href=&#34;https://arxiv.org/abs/2106.14146&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper1&lt;/a&gt; and &lt;a href=&#34;https://www.cambridge.org/core/journals/communications-in-computational-physics/article/abs/fast-evaluation-of-the-caputo-fractional-derivative-and-its-applications-to-fractional-diffusion-equations/AF5FDC74FD7A010ED0ACD291BB1A92B1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper2&lt;/a&gt;. Professor has already accomplished the algorithms in paper1 with a complexity of $O(N_{T}N_{S})$ and has been tested in multiple dimensions in C++. However, the paper2 came up an new algorithms with higher effiency and complexity. The algorithms is accomplished in Matlab.&lt;/p&gt;
&lt;p&gt;$$
\partial_t u(x, t)-\nabla \cdot\left(\partial_t^{1-\alpha} \kappa_\alpha \nabla u-\boldsymbol{F} \partial_t^{1-\alpha} u\right)(x, t)=f(x, t), \quad \text { for } x \in \Omega \text { and } 0&amp;lt;t&amp;lt;T
$$&lt;/p&gt;
&lt;p&gt;My job was about the topics of optimization of the computing algorithms of the time-fractional diffusion equation. My work was based on the newly proposed more efficient Caputo fractional derivative numerical method for a time-fractional equation using Matlab to implement the algorithm in one and two dimensions. And I convert the Matlab code to C++, integrate it with the original code of the second-order accurate scheme algorithms, and test it. This work has succeeded in reducing the complexity of the code from $O(N_{T}^{2}N_{S})$ to $O(N_{S} \cdot logN_{T})O(\log^{2}N_{T})$ in dimensions 1 and 2 and significantly reduces the space complexity.&lt;/p&gt;
&lt;p&gt;However, due to certain reason and time restriction of the project. We only accomplished the code transfer and we trying to improve our merged algorithms in the future.&lt;/p&gt;
&lt;p&gt;We are also very curious about the application of this algorithm in the field of financial mathematics and quantitative finance. Many option-related models ultimately boil down to a diffusion equation, which is a partial differential equation. So the two algorithms have a high similarity, for example, by the two numerical methods Monte Carlo or finite differnece.&lt;/p&gt;
&lt;p&gt;Diffusion Equation:
$$
\frac{\partial \phi(\mathbf{r}, t)}{\partial t}=\nabla \cdot[D(\phi, \mathbf{r}) \nabla \phi(\mathbf{r}, t)]
$$
Spatial derivatives are replaced by finite differences:
$$
\frac{d f}{d x} \rightarrow \frac{f(x+\Delta x)-f(x-\Delta x)}{2 \Delta x} .
$$
Similarly for time derivatives:
$$
\frac{d Q}{d t} \rightarrow \frac{Q^{n+1}-Q^{n-1}}{2 \Delta t}=F^n
$$
This can immediately be solved for $Q^{n+1}$ :
$$
Q^{n+1}=Q^{n-1} \cdot 2\Delta t F^{n}
$$
Ito&amp;rsquo;s lemma: If there is a Wiener process $X$ and a normally distributed increment $dX$ with mean 0 and variance $dt$, then the function $F(X)$ of the increment can be expressed by a Taylor second-order expansion as
$$
d F=\frac{d F}{d X} d X+\frac{1}{2} \frac{d^2 F}{d X^2} d t
$$
More strictly,
$$
d f\left(t, X_t\right)=\left(\frac{\partial f}{\partial t}+\mu_t \frac{\partial f}{\partial x}+\frac{\sigma_t^2}{2} \frac{\partial^2 f}{\partial x^2}\right) d t+\sigma_t \frac{\partial f}{\partial x} d B_t .
$$&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
